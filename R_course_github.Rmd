---
title: "R Project: Konza Groundwater Analysis"
output: github_document
author: Christopher Wheeler
---
## Prepare the R environment 
We will load any relevant packages and set the default for our code visibility in the final report.
```{r message = FALSE, warning = FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(zoo)
library(lubridate)
library(ggplot2)
library(plotly)
library(cowplot)
library(fs)
library(Rcpp)
library(sp)
library(raster)
library(rgdal)
library(rasterVis)
library(sf)
library(tidyverse)
library(dplyr)
library(dataRetrieval)
library(cowplot)
library(reshape2)
library(magrittr)
library(tidyr)
library(readxl)
library(janitor)
```
## Konza Praire LTER Overview
Konza Prairie Biological Station (Konza) was designated as a Long-term Ecological Research Site (LTER) by NSF in 1981. In the 1990s, Dr. Gwen Macpherson coordinated the installation of multiple wells in the N04D watershed at Konza. All that historical groundwater data is accessible via the Konza Long-term Ecological Research Site webpage. Data include GWL measurements, as well as water quality data for many analytes This data I am going to analyze come from one of the many subwatersheds known as N04D. This watershed is grazed by bison for most of the year, and is subject to a controlled burn very four years.Below is a map of the entire site. 
```{r}


```
## Data Tidying and First Look
In this section, we will perform some basic data cleaning operations to get our data ready for further analysis
```{r}
# bring in and examine konza groundwater data set
kgw <- read_csv("kgw.csv", col_types = cols(WLDate = col_character()))
head(kgw)
names(kgw)
summary(kgw)
```
Below are some steps I used to tidy the raw data frame.
```{r warning = FALSE}
# from the summary, it appears that all of the actual chem data is in string format, so we need to convert to numeric
kgw[,11:ncol(kgw)]<- lapply(kgw[,11:ncol(kgw)], as.numeric)

#now convert date from character to proper format and clean up column names
kgw <- kgw %>% 
  mutate(date = lubridate::ymd(WLDate)) %>% 
  clean_names() %>% 
  dplyr::select(-wl_date)
```
Now that the data frame is cleaned up, I can start an exploratory analysis. As we learned in class, a good first pass at this is to simply create a cross plot of all the variables to check for any obvious correlations. When I first tried using plot with the whole data frame, I got an error saying that the margins were too large. I next tried to use a subsetted data frame with just the chemistry
```{r message = FALSE, warning = FALSE}
# subset original df to one with just chemical concentrations

all_na <- function(x) any(!is.na(x))

kgw_2 <- kgw %>% 
  select_if(all_na)

kgw_chem <- kgw_2 %>% 
  dplyr::select(-conduct, -date, -datacode, -rectype, -location, -trans, -plot, -geology, -recyear, -elevation, -sw_date)

names(kgw_chem)

kgw_chem_subset <- kgw_chem %>% 
  dplyr::select(na1, na2, ca1, ca2, nh4_n, no3_n, alkalinity, temp, mg1, cl, so4, k1)
```
## Cross Plot
```{r}
plot(kgw_chem_subset)
```
From this cross plot, a few correlations stand out to me a potentially significant... 

Additionally, as a first pass I want to look at differences among wells screened in different geologic units. First I need to do some subsetting.
```{r}
kgw_2 <- kgw_2 %>% 
  mutate(geology = as_factor(geology))

kgw_geosub <- kgw_2[kgw_2$geology == 'AL' | kgw_2$geology == 'AL' | kgw_2$geology == 'Eis'   
                 | kgw_2$geology == 'Eis 1' | kgw_2$geology == 'Eis 2'  | kgw_2$geology == '1Mor'| kgw_2$geology == 'Mor', ]
```
## Boxplot
```{r warning = FALSE}
ggplot(kgw_geosub, aes(x = factor(geology), y = no3_n, fill = geology)) + 
  geom_boxplot() + 
  theme_cowplot() + 
  xlab("Geologic Unit") + 
  theme(legend.position="none") + 
  ylab(bquote(NO[3]^" -")) 
```

## Denisty Plot

```{r}
ggplot(kgw_geosub, aes(no3_n, fill = geology)) + 
  geom_density(alpha = 0.3) + 
  theme_cowplot() + 
  xlab(bquote(NO[3]^" -")) + 
  ylab("Density")

```

Now bring in second data set with high frequency GWl measurements on well subset
```{r warning = FALSE}
agw <- read_csv("agw.csv") %>% 
  rename(datetime = WLDate) %>% 
  mutate(datetime = lubridate::mdy_hms(datetime)) %>% 
  clean_names()

```
At the end I want three animated maps: gw levels, pulse storage, and stics
```{r}
#animated maps 



```
## Evaluation of Statistical Tests
Below is making a stats dataframe form the `kgw_chem` numeric data frame
```{r warning = FALSE}
# start data frame with column of means
stat_kgw <- data.frame(colMeans(kgw_chem,na.rm=TRUE))

# rename column
stat_kgw <- stat_kgw %>% 
  rename(mean = names(stat_kgw))

# add median
stat_kgw$median<-sapply(kgw_chem, function(med)  meds = median(med,na.rm=TRUE))

# add standard deviations
stat_kgw$sd<-sapply(kgw_chem, function(std)  sds = sd(std,na.rm=TRUE))

# add variance
stat_kgw$var<-sapply(kgw_chem, function(vr)  vars = var(vr,na.rm=TRUE))

# transpose such that stats are row names and analytes are cols
stat_kgw_mx <- as.matrix(stat_kgw)
stat_kgw_mx <- t(stat_kgw_mx)
stat_kgw <- as.data.frame(stat_kgw_mx)

stat_kgw
```
We can draw a few basic conclusions from the stats we have just generated. One is that for all analytes except ba, the median values are smaller than the mean values. This indicates a right skewed or positive skewed distribution. This is very common with environmental data, and water quality data in particular. Below I'll start explicitly evaluating the data distribution, starting with Shapiro-Wilkes. But before that I want to generate historgrams to visually evaluate distributions

## Histograms

```{r warning = FALSE}
# Before Shapiro-Wikes, I want to generate histograms for all analytes
par(mfrow=c(3,4))

for(i in 1:ncol(kgw_chem_subset)) {

  hist(unlist(kgw_chem_subset[,i]), na.rm = TRUE, main = "", xlab=colnames(kgw_chem_subset[i]))

}
```

## Shapiro-Wilkes
Looking at the histograms above, it appears that temperature looks the most normal, while ammonia looks least normal. I will use Shapiro-Wilkes on both of these distributions to test this hypothesis. For this test, if the p value is greater than the chosen alpha level, then the data are normally distributed. 
```{r warning = FALSE}
rm(stat_kgw_mx)

# Loop for w statistic and p-value from Shapiro-Wilkes
stat_kgw[nrow(stat_kgw) + 2, ] <- NA
rownames(stat_kgw)[rownames(stat_kgw) == "5"] = "shapiro_w"
rownames(stat_kgw)[rownames(stat_kgw) == "6"] = "shapiro_p"

for(i in 1:ncol(stat_kgw)){
  
  a <- unlist(kgw_chem[, i])
  st <- shapiro.test(a)
  w_stat <- st[1]
  p_val <- st[2]
  stat_kgw[5, i] <- w_stat
  stat_kgw[6, i] <- p_val
  
}

head(stat_kgw)
```
Contrary to my hypothesis, It appears that NONE of the anlaytes have a shapiro p value above 0.05, and thus none are normaly distributed according to this test

## Kolmogorov-Smirnov Test
Now I want to check normality again using the K-S test. I am interested to see if the results of this test are different from Shapiro-Wilkes. For the K-S test, if the p value is greater than the chosen alpha level, then the data are normally distributed (the same as Shaprio-Wilkes).
```{r warning = FALSE}
stat_kgw[nrow(stat_kgw) + 2, ] <- NA
rownames(stat_kgw)[rownames(stat_kgw) == "7"] = "ks_d"
rownames(stat_kgw)[rownames(stat_kgw) == "8"] = "ks_p"

# Loop to test all cols
for(i in 1:ncol(stat_kgw)){
  
  stat_kgw_unl <- as.matrix(as.numeric(stat_kgw[, i])) 
  mean_kgw<-colMeans(kgw_chem[i], na.rm=T)
  sd_kgw <- sd(unlist(kgw_chem[i]), na.rm=T)
 kgw_ks <- ks.test(stat_kgw_unl, "pnorm", mean=mean_kgw, sd=sd_kgw)
  d_stat <- round(as.numeric(kgw_ks[1]), 4)
  p_value <- round(as.numeric(kgw_ks[2]), 4)
  stat_kgw[7, i] <- d_stat
  stat_kgw[8, i] <- p_value
  
}
head(stat_kgw)
```
Remarkably, results of the K-S test contrast quite strongly with Shapiro. According to K-S, all analytes show a normal distribution except Cl, pH, and Si.

## Kolmogorov-Smirnov Test for Log-normal Distribution
Because a lot of histograms and density curves appear to follow a log-normal distribution (as many hydrologic and environmental data sets do), I would like to perform the K-S test again, but testing for a log-normal distribution, to see if those analytes that didn't show a normal distribution end up showing a log-normal distribution. 
```{r warning = FALSE}

stat_kgw[nrow(stat_kgw) + 2, ] <- NA
rownames(stat_kgw)[rownames(stat_kgw) == "9"] = "ks_d_log"
rownames(stat_kgw)[rownames(stat_kgw) == "10"] = "ks_p_log"

# Loop to test all cols
for(i in 1:ncol(stat_kgw)){
  
  stat_kgw_unl <- as.matrix(as.numeric(stat_kgw[,i])) #as.matrix unlists the column
  mean_kgw<-colMeans(kgw_chem[i],na.rm=T)
  sd_kgw<-sd(unlist(kgw_chem[i]),na.rm=T)
 kgw_ks<-ks.test(stat_kgw_unl,"plnorm",mean=mean_kgw,sd=sd_kgw)
  d_stat_log<-round(as.numeric(kgw_ks[1]),4)
  p_value_log<-round(as.numeric(kgw_ks[2]),4)
  stat_kgw[9,i]<-d_stat_log
  stat_kgw[10,i]<-p_value_log
  
}
head(stat_kgw)
```
The p-values for the log-normal K-S test are all at 0, indicating that none of these distributions are log-normally distributed. So it turns out that Cl, pH, and Si have neither a normal distribution or a log-normal distribution. 

## QQ Plots
Since we now know that most of the analytes in this data set are indeed normally distributed, we can back up that interpretation by creating QQ plots for a subset of analytes 
```{r}
par(new = TRUE)
par(mfrow=c(3,4))

names(kgw_chem_subset)

qqnorm(kgw_chem_subset$na1, main = "na1")
qqnorm(kgw_chem_subset$na2, main = "na2")
qqnorm(kgw_chem_subset$ca1, main = "ca1")
qqnorm(kgw_chem_subset$nh4_n, main = "nh4_n")
qqnorm(kgw_chem_subset$no3_n, main = "no3_n")
qqnorm(kgw_chem_subset$alkalinity, main = "alkalinity")
qqnorm(kgw_chem_subset$temp, main = "temp")
qqnorm(kgw_chem_subset$mg1, main = "mg1")
qqnorm(kgw_chem_subset$cl, main = "cl")
qqnorm(kgw_chem_subset$so4, main = "so4")
qqnorm(kgw_chem_subset$k1, main = "k1")


```
This result is interesting to me, because a lot of these don't appear as very straight lines, although most are somewhat straight. This to me reinforces the fact that Shapiro identified almost no normal distributions, while K-S identified most analytes as normal

## Identifying Outliers: Rosner Test




